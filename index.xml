<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tao of Code</title>
    <link>http://taoofcode.net/</link>
    <description>Recent content on Tao of Code</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>All rights reserved - 2015</copyright>
    <lastBuildDate>Tue, 20 Oct 2015 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://taoofcode.net/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>On Triangles</title>
      <link>http://taoofcode.net/on-triangles/</link>
      <pubDate>Tue, 20 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>http://taoofcode.net/on-triangles/</guid>
      <description>

&lt;p&gt;In &lt;a href=&#34;ttps://mitpress.mit.edu/sicp/full-text/book/book-Z-H-11.html#%_sec_1.2.2&#34;&gt;SICP 1.2.2 Tree Recursion&lt;/a&gt; we have Exercise 1.12 which asks us to code up a recursive solution to compute the elements of Pascals Triangle.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    1
   1 1
  1 2 1
 1 3 3 1
1 4 6 4 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Pascals Triangle has two rules - the numbers on the edge are 1 and the numbers inside the triangle is the sum of the two numbers in the previous row.&lt;/p&gt;

&lt;p&gt;A recursive solution is fairly simple :&lt;/p&gt;

&lt;p&gt;(in Clojure)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-clojure&#34;&gt;(defn triangle
  [col row]
  (if (or (= col 0) (= col row))
       1
       (+ (triangle (dec col) (dec row))
          (triangle col (dec row)))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the column is the first or the last one return 0 otherwise recurse up to get the two values in the prior row. These are then summed and returned. We can print out our triangle with some nested loops :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(doseq [row (range 0 5)]
  (doseq [col (range 0 (inc row))]
    (print (triangle col row) &amp;quot; &amp;quot;))
  (println))

1  
1  1  
1  2  1  
1  3  3  1  
1  4  6  4  1  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is all good, but quite unsatisfying. It would be better if we could get the entire row in a single call:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(defn pad
  [row]
  (concat &#39;(0) row &#39;(0)))

(defn triangle2
  [row]
  (if (= 0 row)
    &#39;(1)
    (let [previous (pad (triangle2 (dec row)))]
      (map +&#39; previous (next previous)))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we recurse down to the first row, which returns &lt;code&gt;&#39;(1)&lt;/code&gt;. Then for each successive row we pad the prior one with 0, so &lt;code&gt;&#39;(1 2 1)&lt;/code&gt; becomes &lt;code&gt;&#39;(0 1 2 1 0)&lt;/code&gt;. And then we add that row with itself offset by one using &lt;code&gt;map&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  (0 1 2 1 0)
  (1 2 1 0)
  -----------
  (1 3 3 1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And we can print out our triangle :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(doseq [row (range 5)] (println (triangle2 row)))

(1)
(1 1)
(1 2 1)
(1 3 3 1)
(1 4 6 4 1)
nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However this is hopelessly inefficient. For each row we have to calculate the prior rows, every time. It would be much better and more idiomatic if we could create a lazy sequence of these rows so that each step builds on the prior ones.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(defn lazy-triangle
  ([] (lazy-triangle &#39;(1)))
  ([previous]
   (lazy-seq
       (cons previous
          (lazy-triangle (let [padded (pad previous)]
                           (map +&#39; padded (next padded))))))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we cons the previous row to a lazy-seq to build up our lazy sequence:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(doseq [row (take 5 (lazy-triangle))] (println row))

(1)
(1 1)
(1 2 1)
(1 3 3 1)
(1 4 6 4 1)
nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above function can be rewritten much more succintly using &lt;a href=&#34;http://clojuredocs.org/clojure.core/iterate&#34;&gt;iterate&lt;/a&gt; :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(def lazy-triangle2 (iterate (fn [previous]
                               (let [padded (pad previous)]
                                 (map +&#39; padded (next padded))))
                             &#39;(1)))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;(doseq [row (take 5 lazy-triangle2)] (println row))

(1)
(1 1)
(1 2 1)
(1 3 3 1)
(1 4 6 4 1)
nil
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;sierpinski-triangle:d992317aacfe2cfd22e5b82457a6da35&#34;&gt;Sierpinski Triangle&lt;/h2&gt;

&lt;p&gt;Now the interesting thing about Pascals Triangle is that if you keep the odd numbers and clear out the even numbers, you end up with &lt;a href=&#34;https://en.wikipedia.org/wiki/Sierpinski_triangle&#34;&gt;Sierpinski&amp;rsquo;s triangle&lt;/a&gt;. Lets try it. Now instead of adding the rows together, we will add and then Mod with 2 to ensure we only have 1 or 0 in our triangle.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(defn +mod2
  [a b]
  (mod (+ a b) 2))

(def sierpinski-triangle (iterate (fn [previous]
                                    (let [padded (pad previous)]
                                      (map +mod2 padded (next padded))))
                                  &#39;(1)))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;(doseq [row (take 10 sierpinski-triangle)] (println row))

(1)
(1 1)
(1 0 1)
(1 1 1 1)
(1 0 0 0 1)
(1 1 0 0 1 1)
(1 0 1 0 1 0 1)
(1 1 1 1 1 1 1 1)
(1 0 0 0 0 0 0 0 1)
(1 1 0 0 0 0 0 0 1 1)
nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now you do have to squint a little in order to see the triangle there - ideally the rows would be centralised, but the triangle is there.&lt;/p&gt;

&lt;h2 id=&#34;sierpinski-pyramid:d992317aacfe2cfd22e5b82457a6da35&#34;&gt;Sierpinski Pyramid&lt;/h2&gt;

&lt;p&gt;Lets expand our pyramid into the third dimension.&lt;/p&gt;

&lt;p&gt;Adding a new dimension means instead of each row being represented by a vector, it will now be a vector of vectors. Something like :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[[1]]
[[1 1]
 [1 1]]
[[1 1 1]
 [1 0 1]
 [1 1 1]]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Iterating over each row will look something like :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
(iterate next-level [[1]])

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As before we first need to pad each row. This time we need to do it in 3 dimensions.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(defn pad
  [previous]
  (let [len (-&amp;gt; previous count (+ 2))]
    `(~(repeat len 0)
      ~@(map (fn [a] `(0 ~@a 0)) previous)
      ~(repeat len 0))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We get the length (note each level of the pyramid is a square, the length and width will always be equal) of the previous level and add two (one for each side). Then we add a new list of zeros at the start and end of the previous rows - each of which is also mapped to add zeros around each row.&lt;/p&gt;

&lt;p&gt;We are taking advantage of Clojures list templating features to help us build up our list. Usually these are used for macros, but they can be very useful to easily build up lists as well.&lt;/p&gt;

&lt;p&gt;When creating a 2d triangle, we would add the numbers from the two columns above in the preceeding level. Now that we are in 3d we need to add the four numbers from the above rows and columns in both directions. To acheive this we need to pair each vector within the level above:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(defn pairs
  [[x &amp;amp; xs]]
  (lazy-seq
   (cons [x (first xs)]
         (if (seq (rest xs))
           (pairs xs)
           nil))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The pairs function creates a sequence of vectors of each row in the list together with the ensuing row.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
 (pairs [[0 0 0] [0 1 0] [0 0 0]])

([[0 0 0] [0 1 0]]
 [[0 1 0] [0 0 0]])

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that we have each pair of padded rows, we can add them up.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
(map (fn [[a b]]
     (map +mod2 a b (next a) (next b)))
     pairs)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We have a nested map so we can get each pair of rows and each pair of columns within those rows. This gives us the four values above which combine to make the value for this column.&lt;/p&gt;

&lt;p&gt;We can then put this all together with the following function.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
(defn next-level
  [previous]
  (-&amp;gt;&amp;gt; previous pad pairs add-rows))

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can now create our 3D pyramid.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
(take 4 (iterate next-level [[1]]))

([[1]] [[1 1] [1 1]] [[1 0 1] [0 0 0] [1 0 1]] [[1 1 1 1] [1 1 1 1] [1 1 1 1] [1 1 1 1]])

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This isn&amp;rsquo;t a particularly pleasant way to view our pyramid. Minecraft would be a much better way. Using &lt;a href=&#34;https://github.com/SevereOverfl0w/bukkure&#34;&gt;Bukkure&lt;/a&gt; we can create plugins for Minecraft in Clojure.&lt;/p&gt;

&lt;p&gt;Here are some of our pyramids :&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://taoofcode.net/img/shot1.png&#34; alt=&#34;Sierpinski Pyramid&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://taoofcode.net/img/shot2.png&#34; alt=&#34;Sierpinski Pyramid&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;Flying around a pyramid can be particularly satisfying.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://taoofcode.net/img/pyramid.gif&#34; alt=&#34;Sierpinski Pyramid&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;The source code for the plugin can be found &lt;a href=&#34;https://github.com/FungusHumungus/bukkure-fractalz&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Cond and friends</title>
      <link>http://taoofcode.net/cond-and-friends/</link>
      <pubDate>Fri, 12 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://taoofcode.net/cond-and-friends/</guid>
      <description>

&lt;p&gt;There are a number of different cond&amp;rsquo;s in Clojure.&lt;/p&gt;

&lt;h2 id=&#34;cond:1765d41f4434e779fd36523cc876cd66&#34;&gt;cond&lt;/h2&gt;

&lt;p&gt;The classic cond. This replaces the standard &lt;code&gt;if...else if....else&lt;/code&gt; that you find in other languages. It takes a set of test and expression pairs. For the first test that evaluates to &lt;code&gt;true&lt;/code&gt; it will evaluate and return its corresponing expression.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(cond (is-banana? me) &amp;quot;I am a banana&amp;quot;
      (is-slug? me) &amp;quot;I am a slug&amp;quot;
      :else &amp;quot;I am a turnip&amp;quot;)

=&amp;gt; &amp;quot;I am a slug&amp;quot;      
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;cond-1:1765d41f4434e779fd36523cc876cd66&#34;&gt;cond-&amp;gt;&lt;/h2&gt;

&lt;p&gt;Now cond short circuits - it will stop at the first true expression. You may think &amp;ldquo;aaarg.. but more than one of my expressions may be true, I want all my true expressions to evaluate&amp;rdquo;. In this case you probably want to use &lt;code&gt;cond-&amp;gt;&lt;/code&gt;. &lt;code&gt;cond-&amp;gt;&lt;/code&gt; takes an initial form  and then a set of test and expression pairs. It will then thread that initial form through each expression where the test evaluates to true.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(cond-&amp;gt; &amp;quot;I am a &amp;quot; (is-slimey? me) (str &amp;quot;slimey &amp;quot;)
                  (is-banana? me) (str &amp;quot;banana&amp;quot;)
                  (is-slug? me) (str &amp;quot;slug&amp;quot;))

=&amp;gt; &amp;quot;I am a slimey slug&amp;quot;                  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;cond-2:1765d41f4434e779fd36523cc876cd66&#34;&gt;cond-&amp;gt;&amp;gt;&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;cond-&amp;gt;&amp;gt;&lt;/code&gt; is pretty much the same as &lt;code&gt;cond-&amp;gt;&lt;/code&gt; except &lt;code&gt;cond-&amp;gt;&lt;/code&gt; threads first (puts the threaded param first in the argument list) and &lt;code&gt;cond-&amp;gt;&amp;gt;&lt;/code&gt; threads last (puns the threaded param last in the argument list).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(cond-&amp;gt;&amp;gt; &amp;quot;I am a &amp;quot; (is-slimey? me) (str &amp;quot;slimey &amp;quot;)
                   (is-banana? me) (str &amp;quot;banana&amp;quot;)
                   (is-slug? me) (str &amp;quot;slug&amp;quot;))

=&amp;gt; &amp;quot;slug slimey I am a&amp;quot;                  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;when:1765d41f4434e779fd36523cc876cd66&#34;&gt;when&lt;/h2&gt;

&lt;p&gt;You might be thinking, &amp;ldquo;I don&amp;rsquo;t want to thread an argument through all the true expressions - I just want to evaluate them&amp;rdquo;. The only reason you would want to do this would be if those exressions had side effects and you wanted to ignore their results.&lt;/p&gt;

&lt;p&gt;If you really want to ignore the results just use &lt;code&gt;when&lt;/code&gt; :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(when (is-slimey? me) (send-slime))
(when (is-banana? me) (send-banana))
(when (is-slug? me) (send-slug))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;case:1765d41f4434e779fd36523cc876cd66&#34;&gt;case&lt;/h2&gt;

&lt;p&gt;If you find you are writing this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(cond (= me &amp;quot;banana&amp;quot;) &amp;quot;I am a banana&amp;quot;
      (= me &amp;quot;slug&amp;quot;) &amp;quot;I am a slug&amp;quot;
      :else &amp;quot;I am a turnip&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You should probably be using &lt;code&gt;case&lt;/code&gt; instead. &lt;code&gt;case&lt;/code&gt; takes an expression and thes a set of constant and expression pairs. For the first constant that is equal to the result of our expression the result of the corresponding expression is returned. There can be a single default expression at the end of our clauses that is evaluated and returned if none of the given constants are equal.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(case me
      &amp;quot;banana&amp;quot; &amp;quot;I am a banana&amp;quot;
      &amp;quot;slug&amp;quot; &amp;quot;I am a slug&amp;quot;
      &amp;quot;I am a turnip)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If none of the clauses match and there is no default you will get an IllegalArgumentException.&lt;/p&gt;

&lt;h2 id=&#34;condp:1765d41f4434e779fd36523cc876cd66&#34;&gt;condp&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;case&lt;/code&gt; is good and all, but that only uses = to determine a match. What if we wanted to use some other predicate instead - say a regex match - we could fall back to cond.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(cond (re-seq #&amp;quot;handsome&amp;quot; (looks me)) &amp;quot;Yes I am&amp;quot;
      (re-seq #&amp;quot;funky&amp;quot; (looks me)) &amp;quot;I&#39;m ugly but at least I&#39;m funky&amp;quot;
      :else &amp;quot;Oh dear&amp;quot;)

=&amp;gt; &amp;quot;I&#39;m ugly but at least I&#39;m funky&amp;quot;      
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, here it would be neater to use &lt;code&gt;condp&lt;/code&gt;. &lt;code&gt;condp&lt;/code&gt; takes a predicate, a parameter (which is passed as the second parameter to the predicate) and a set of test expressions to result expressions. Then it runs through the clauses and passes each result of the test expression as the first parameter to the predicate. An example might make it clearer. The above can be rewritten as :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(condp re-seq (looks me)
       #&amp;quot;handsome&amp;quot; &amp;quot;Yes I am&amp;quot;
       #&amp;quot;funky&amp;quot; &amp;quot;I&#39;m ugly but at least I&#39;m funky&amp;quot;
       &amp;quot;Oh dear&amp;quot;)

=&amp;gt; &amp;quot;I&#39;m ugly but at least I&#39;m funky&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;condp&lt;/code&gt; is even better than that. If we separate our test clause and result clause with a &lt;code&gt;:&amp;gt;&amp;gt;&lt;/code&gt; then the result of running the predicate with the test clause gets passed to the result clause - which must now be a function.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(condp re-find (looks me)
       #&amp;quot;.*handsome.*&amp;quot; :&amp;gt;&amp;gt; #(str &amp;quot;Yes I am&amp;quot; %)
       #&amp;quot;.*funky.*&amp;quot; :&amp;gt;&amp;gt; #(str &amp;quot;I&#39;m ugly but at least I&#39;m &amp;quot; %)
       &amp;quot;Oh dear&amp;quot;)

=&amp;gt; &amp;quot;I&#39;m ugly but at least I&#39;m Big and funky&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;and-or:1765d41f4434e779fd36523cc876cd66&#34;&gt;and &amp;amp; or&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;cond&lt;/code&gt; can be implemented just using the &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; boolean operators.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;or&lt;/code&gt; will short-circuit (stop processing) at the first true expression (everything apart from false and nil) and will return the result of evaluating it :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(or (= 3 2) (= 4 3) &amp;quot;fish&amp;quot; (println &amp;quot;ooops&amp;quot;))

=&amp;gt; &amp;quot;fish&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;and&lt;/code&gt; will short-circuit at the first false expression. If there is a false value it returns false, otherwise it will return the result of the final expression :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(and true 4 :a &amp;quot;fish&amp;quot;)

=&amp;gt; fish

(and true (= 3 &amp;quot;fish&amp;quot;) (println &amp;quot;ooops&amp;quot;))

=&amp;gt; false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can put these two together to emulate our initial &lt;code&gt;cond&lt;/code&gt; :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(or (and (is-banana? me) &amp;quot;I am a banana&amp;quot;)
    (and (is-slug? me) &amp;quot;I am a slug&amp;quot;)
    &amp;quot;I am a turnip&amp;quot;)

=&amp;gt; &amp;quot;I am a slug&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With a little imagination you can create all kinds of complex conditional structures just using &lt;code&gt;or&lt;/code&gt; and &lt;code&gt;and&lt;/code&gt;. Whether you should or not is up to you!&lt;/p&gt;

&lt;p&gt;Enjoy!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Creating a plugin system in Angular JS with the $compile service</title>
      <link>http://taoofcode.net/creating-a-plugin-system-with-the-compile-provider/</link>
      <pubDate>Fri, 04 Jul 2014 00:00:00 +0000</pubDate>
      
      <guid>http://taoofcode.net/creating-a-plugin-system-with-the-compile-provider/</guid>
      <description>

&lt;p&gt;Angular JS directives are powerful. Using them allows you to manipulate pretty much everything in the DOM that you would want to. But there is one exception. Dynamically creating a directive depending on data received from the server, something often used for plugin systems. Luckily we can access the $compileProvider directly to work around these limitations.&lt;/p&gt;

&lt;h2 id=&#34;plugins:f5a7b37877fefd89df86f9babe1cce64&#34;&gt;Plugins&lt;/h2&gt;

&lt;p&gt;Say you are designing a plugin system. Each plugin is implemented as a different directive. The plugin to use is stored in the database and sent down from the server.&lt;/p&gt;

&lt;p&gt;Lets set up a couple of very simple directives:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-javascript&#34;&gt;angular.module(&#39;anApp&#39;).directive(&#39;one&#39;, function() {
    return {
        template: &#39;&amp;lt;span&amp;gt;I am one&amp;lt;/span&amp;gt;&#39;   
    };
});

angular.module(&#39;anApp&#39;).directive(&#39;two&#39;, function() {
    return {
        template: &#39;&amp;lt;span&amp;gt;I am two&amp;lt;/span&amp;gt;&#39;   
    };
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our controller grabs the plugin to use from a factory and attaches it to the scope. This factory has presumably queried the server to get the name of the plugin we need :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-javascript&#34;&gt;angular.module(&#39;anApp&#39;).controller(&#39;aCtrl&#39;, function($scope, aFactory) {
    aFactory().then(function(plugin) {
       $scope.plugin = plugin; // Either &#39;one&#39; or &#39;two&#39;.
    });
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we have a problem. How are we going to render the required directive?&lt;/p&gt;

&lt;h3 id=&#34;naive-approaches:f5a7b37877fefd89df86f9babe1cce64&#34;&gt;Naive approaches&lt;/h3&gt;

&lt;p&gt;A naive approach might be something like :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-javascript&#34;&gt;&amp;lt;div ng-app=&#39;anApp&#39;&amp;gt;
    &amp;lt;div ng-controller=&#39;aCtrl&#39;&amp;gt;
        &amp;lt;div {{plugin}}&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That doesn&amp;rsquo;t work. The &lt;code&gt;{{plugin}}&lt;/code&gt; does not get interpolated in time and so the directive is not rendered.&lt;/p&gt;

&lt;p&gt;Another approach that could almost work is specifying a directive that uses a function to specify the template.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-javascript&#34;&gt;.directive(&#39;taoPlugin&#39;, function() {
    return {
        template: function(element, attrs) { 
            var p = attrs.plugin;
            return &#39;&amp;lt;&#39; + p + &#39; /&amp;gt;&#39;; 
        }  
    }   
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This could almost work. The problem is the attrs doesn&amp;rsquo;t contain the correct plugin name. We want to pull the plugin name out of our parents controllers scope. There is no way of pulling the actual data out of the scope into the attrs collection. (Feel free to correct me if I am wrong - it would be great if there was!)&lt;/p&gt;

&lt;p&gt;So we just end up with the following output rendered to page :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-javascript&#34;&gt;&amp;lt;one /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;compile-to-the-rescue:f5a7b37877fefd89df86f9babe1cce64&#34;&gt;$compile to the rescue.&lt;/h3&gt;

&lt;p&gt;$compile is the provider that takes an HTML template string and creates a template function. When this template function is called with a &lt;code&gt;$scope&lt;/code&gt; it spits out HTML. It is the provider at the core of Angular which enables directives to manipulate the DOM using the Angular templating language.&lt;/p&gt;

&lt;p&gt;It takes template HTML :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-javascript&#34;&gt;&amp;lt;div&amp;gt;{{something}}&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and returns a function, which we call with a scope :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-javascript&#34;&gt;$scope.something = &#39;Interesting text&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and compiles it to :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-javascript&#34;&gt;&amp;lt;div&amp;gt;Interesting text&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(Note the text is not acually interpolated until it is rendered to the DOM.)&lt;/p&gt;

&lt;p&gt;So, if we pass &lt;code&gt;$compile&lt;/code&gt; the string : &lt;code&gt;&#39;&amp;lt;one /&amp;gt;&#39;&lt;/code&gt; it is actually going to compile our &lt;code&gt;one&lt;/code&gt; directive. Naturally because we are just passing a string, we will have no problems building this string up at run time to whatever we require.&lt;/p&gt;

&lt;p&gt;Then all we need to do is append this html to a given element for it to be rendered on the page. To access an element on the page we need to create a directive. So lets create this directive.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-javascript&#34;&gt;angular.module(&#39;anApp&#39;).directive(&#39;taoPlugin&#39;, [&#39;$compile&#39;, function($compile) {
    return {
        restrict: &#39;E&#39;,
        scope: { &#39;plugin&#39;: &#39;=&#39; },
        link: function(scope, element) {
            var template = &#39;&amp;lt;&#39; + scope.plugin + &#39; /&amp;gt;&#39;,
                compiled = $compile(template)(scope);

            element.append(compiled);            
        }   
    }   
}]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can then setup our directive simply :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-javascript&#34;&gt;&amp;lt;tao-plugin plugin=&#39;plugin&#39;&amp;gt;&amp;lt;/tao-plugin&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The directive we have set in our controller  : &lt;code&gt;$scope.plugin = plugin;&lt;/code&gt; is the directive that is rendered.&lt;/p&gt;

&lt;p&gt;Here is a &lt;a href=&#34;http://jsfiddle.net/ht8ZQ/26/&#34;&gt;jsFiddle&lt;/a&gt; that demonstrates this.&lt;/p&gt;

&lt;p&gt;Note our directive here isn&amp;rsquo;t passing on any parameters to the plugin directive. This could be achieved by looping round the attr array that gets passed into the link function.&lt;/p&gt;

&lt;p&gt;Also note that the directive has isolate scope. This gets passed on to the plugin directives. If you want a different scope for your plugins, you would need to change the scope of this plugin as well.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Javascript Schönfinkeling</title>
      <link>http://taoofcode.net/javascript-schonfinkeling/</link>
      <pubDate>Tue, 18 Mar 2014 00:00:00 +0000</pubDate>
      
      <guid>http://taoofcode.net/javascript-schonfinkeling/</guid>
      <description>&lt;p&gt;In Javascript is it extremely common to pass function as parameters to other functions.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-javascript&#34;&gt;function addOne(a) {
    return a + 1;
}

[1,2,3,4].map(addOne);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is all good. However when your function takes more than one parameter, you can&amp;rsquo;t just pass the function directly so you need to create a new function which calls the original one:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-javascript&#34;&gt;function add(a,b) {
    return a + b;
}

[1,2,3,4].map(function(a) {
    return add(a,1);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This does work, but you do lose some expressiveness by doing so - the semantics of the code gets lost in the syntax.&lt;/p&gt;

&lt;p&gt;We can break up our add function to return a nested series of functions - one for each parameter:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-javascript&#34;&gt;function add(a) {
    return function(b) {
        return a + b;
    };
}

[1,2,3,4].map(add(1));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This technique of taking a function that accepts multiple parameters and converting it into a chain of functions, each accepting one parameter, is known as &lt;a href=&#34;https://en.wikipedia.org/wiki/Currying&#34;&gt;Currying&lt;/a&gt; (also known as Schönfinkeling).&lt;/p&gt;

&lt;p&gt;Although it is more expressive to call, it is a bit of a pain to have to write that curried function. It would be better if we could write something that could convert a standard function into a curried function.&lt;/p&gt;

&lt;p&gt;So, instead of capturing the parameters in a series of nested closures, the following function will collect the passed parameter in an array. This is captured in a closure that is then returned for the next call in the chain. When all the required parameters have been collected, it calls the our function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-javascript&#34;&gt;var curry = function(fn) {

  var curryOrCall = function(args) {
    if (fn.length === args.length) {
      // All parameters have been passed, call the original function
      return fn.apply(this, args);
    }
    
    return function(param) {
      // Create a copy of the arguments
      var myargs=args.slice(0); 
      // Add the new argument to the list.
      myargs.push(param); 
      return curryOrCall(myargs);
    };
  };
  
  return curryOrCall([]); 
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Used like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-javascript&#34;&gt;var add = curry(add(a,b) {
    return a + b;
});

[1,2,3,4].map(add(1));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is all good and well, but we can only pass one parameter at a time, so it can get a little annoying, and inefficient, if there are several parameters you need to deal with.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-javascript&#34;&gt;var add3 = curry(add(a,b,c) {
    return a + b + c;
});

[1,2,3,4].map(add3(1)(2));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Pure currying means that each function in the chain &lt;strong&gt;must&lt;/strong&gt; take only one parameter. In practical terms, often we will have multiple parameters that we want to pass, like: &lt;code&gt;[1,2,3,4].map(add3(1,2));&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;###Partial function application&lt;/p&gt;

&lt;p&gt;This is what &lt;em&gt;partial function application&lt;/em&gt; is all about. Lets adjust our &lt;code&gt;curry&lt;/code&gt; function to enable multiple parameters at a time:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-javascript&#34;&gt;var partial = function(fn) {

  var partialOrCall = function(args) {
    if (fn.length === args.length) {
      // All parameters have been passed, call the original function
      return fn.apply(this, args);
    }

    return function(/* arguments */) {
      // Add all passed arguments to our arguments list
      var myargs=args.slice(0).concat(
        Array.prototype.slice.call(arguments, 0));
      return partialOrCall(myargs);
    };
  };

  return partialOrCall([]);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So now it works with multiple parameters:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-javascript&#34;&gt;var add = partial(add3(a,b,c) {
    return a + b + c;
});

[1,2,3,4].map(add3(1,2));

// Note currying still works if you really want to:
[1,2,3,4].map(add3(1)(2));

&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;###Uses&lt;/p&gt;

&lt;p&gt;####Passing to higher-order functions
Partial function application lets you be more expressive when passing functions to higher-order functions such as map.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-javascript&#34;&gt;[1,2,3,4].map(function(a) {
    return add(4, a);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;vs&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-javascript&#34;&gt;[1,2,3,4].map(add(4));
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;####Creating member functions&lt;/p&gt;

&lt;p&gt;If you have an object whose member functions invoke largely the same functionality but with some slight differences, you can set these members to be a partially applied function against one common function. This  is used in Angular JS:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-javascript&#34;&gt; function supportObject(delegate) {
    return function(key, value) {
      ...
    };
  }

providerCache = {
        $provide: {
            provider: supportObject(provider),
            factory: supportObject(factory),
            service: supportObject(service),
            value: supportObject(value),
            constant: supportObject(constant)
            ...
          }
      },
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(This could be rewritten with our partial method as):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-javascript&#34;&gt;var supportObject = partial(function(delegate, key, value) {
      ...
}

providerCache = {
        $provide: {
            provider: supportObject(provider),
            factory: supportObject(factory),
            service: supportObject(service),
            value: supportObject(value),
            constant: supportObject(constant)
            ...
          }
      },
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Studying the Angular JS Injector - loading modules</title>
      <link>http://taoofcode.net/studying-the-angular-injector-loading-modules/</link>
      <pubDate>Mon, 10 Mar 2014 00:00:00 +0000</pubDate>
      
      <guid>http://taoofcode.net/studying-the-angular-injector-loading-modules/</guid>
      <description>

&lt;p&gt;(This post is part of a series &lt;a href=&#34;http://taoofcode.net/studying-the-angular-injector/&#34;&gt;studying the AngularJS injector&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;A module gets loaded with the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-javascript&#34;&gt; function loadModules(modulesToLoad){
    var runBlocks = [], moduleFn, invokeQueue, i, ii;
    forEach(modulesToLoad, function(module) {
      if (loadedModules.get(module)) return;
      loadedModules.put(module, true);

      try {
        if (isString(module)) {
          moduleFn = angularModule(module);
          runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks);

          for(invokeQueue = moduleFn._invokeQueue, i = 0, ii = invokeQueue.length; i &amp;lt; ii; i++) {
            var invokeArgs = invokeQueue[i],
                provider = providerInjector.get(invokeArgs[0]);

            provider[invokeArgs[1]].apply(provider, invokeArgs[2]);
          }
        } else if (isFunction(module)) {
            runBlocks.push(providerInjector.invoke(module));
        } else if (isArray(module)) {
            runBlocks.push(providerInjector.invoke(module));
        } else {
          assertArgFn(module, &#39;module&#39;);
        }
      } catch (e) {
        if (isArray(module)) {
          module = module[module.length - 1];
        }
        if (e.message &amp;amp;&amp;amp; e.stack &amp;amp;&amp;amp; e.stack.indexOf(e.message) == -1) {
          // Safari &amp;amp; FF&#39;s stack traces don&#39;t contain error.message content
          // unlike those of Chrome and IE
          // So if stack doesn&#39;t contain message, we create a new string that contains both.
          // Since error.stack is read-only in Safari, I&#39;m overriding e and not e.stack here.
          /* jshint -W022 */
          e = e.message + &#39;\n&#39; + e.stack;
        }
        throw $injectorMinErr(&#39;modulerr&#39;, &amp;quot;Failed to instantiate module {0} due to:\n{1}&amp;quot;,
                  module, e.stack || e.message || e);
      }
    });
    return runBlocks;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The function returns an array of runBlocks - functions which are to be invoked after loading.&lt;/p&gt;

&lt;p&gt;There are three ways to define a module in AngularJS. The first is by specifying a runBlock directly :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-javascript&#34;&gt;angular.module(function($httpProvider) {
    console.log(&#39;Module is now running&#39;);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or by passing an array :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-javascript&#34;&gt;angular.module([&#39;$httpProvider&#39;, function($httpProvider) {
    ...
}]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In both these cases the module is run with this line:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-javascript&#34;&gt;    runBlocks.push(providerInjector.invoke(module));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The module function is invoked against the providerInjector. This means that we can inject the elusive &lt;code&gt;$provide&lt;/code&gt; object into this function. This can then be used to register services directly.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-javascript&#34;&gt;var injector = angular.injector([function($provide) {
    $provide.value(&#39;anInterestingFact&#39;, &#39;An ant has two stomachs. One for its own food and another for food to share&#39;);
}]);

injector.get(&#39;anInterestingFact&#39;);
// &#39;An ant has two stomachs. One for its own food and another for food to share&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Most likely the module will be defined with a string that identifies the name of the module. A module in Angular is typically setup as follows :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-javascript&#34;&gt;angular.module(&#39;myModule&#39;, [dependency]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the module has been defined in this way, the following code is run:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-javascript&#34;&gt;moduleFn = angularModule(module);
runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks);

for(invokeQueue = moduleFn._invokeQueue, i = 0, ii = invokeQueue.length; i &amp;lt; ii; i++) {
    var invokeArgs = invokeQueue[i],
        provider = providerInjector.get(invokeArgs[0]);

    provider[invokeArgs[1]].apply(provider, invokeArgs[2]);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First we retrieve the module object using the angularModule function. This function is defined outside of the injector and is just an alias for the angular.module function. When the module is setup two arrays are populated : &lt;code&gt;_runBlocks&lt;/code&gt; and &lt;code&gt;_invokeQueue&lt;/code&gt;. (The code that sets this module up is not within the injector module, so I won&amp;rsquo;t be looking at this for the moment.)&lt;/p&gt;

&lt;h3 id=&#34;runblocks:5c09760811a7c5ce0c75a80fce570e0d&#34;&gt;_runBlocks&lt;/h3&gt;

&lt;p&gt;This gets populated with functions specified in the &lt;code&gt;angular.module(&#39;myModule&#39;).run&lt;/code&gt; block. This code needs to be invoked as soon as the module is loaded. So we concat this array to our runBlocks return.&lt;/p&gt;

&lt;h3 id=&#34;invokequeue:5c09760811a7c5ce0c75a80fce570e0d&#34;&gt;_invokeQueue&lt;/h3&gt;

&lt;p&gt;The _invokeQueue is populated with each service that is added to the module using the familiar &lt;code&gt;angular.module(&#39;myModule&#39;).controller&lt;/code&gt;, &lt;code&gt;angular.module(&#39;myModule&#39;).directive&lt;/code&gt; et al. calls. Each item in the queue is an array with three elements. The first is the provider that will invoke the service, the second is the method on the provider to use and the third element is an array of any arguments passed to the service.&lt;/p&gt;

&lt;p&gt;Lets look at an example to see how it all fits together. Say we setup our module as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-javascript&#34;&gt;angular.module(&#39;aNiceModule&#39;, [])
        .run(function() {
            console.log(&#39;running...&#39;);
        })
        .controller(&#39;aNiceController&#39;, function($scope) {
            console.log(&#39;setting up controller&#39;);
        });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can call &lt;code&gt;angular.bootstrap(window.document.body, [&#39;aNiceModule&#39;]);&lt;/code&gt; to kick off the module loading. The &lt;code&gt;aNiceModule&lt;/code&gt; module will have one entry in _runBlocks:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-javascript&#34;&gt;function() {
    console.log(&#39;running...&#39;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and one entry in &lt;code&gt;_invokeQueue&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-javascript&#34;&gt;[&#39;$controllerProvider&#39;, &#39;register&#39;, [&#39;aNiceModule&#39;, function($scope) {...}]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;$controllerProvider&lt;/code&gt; is the built-in Angular provider that enables registering controllers. Calling register will add this service to the list of available controllers. Note that nothing gets added to the injectors cache. This means controllers cannot be injected into a service. If you really needed to get access to a controller (you do when unit testing) you would inject the &lt;code&gt;$controller&lt;/code&gt; provider and retreive the controller by calling &lt;code&gt;get(controllerName)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Lets try creating a factory service:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-javascript&#34;&gt;angular.module(&#39;aNiceModule&#39;, [])
        .factory(&#39;aNiceFactory&#39;, function() {
            console.log(&#39;setting up factory&#39;);
            return {};
        });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When we load this module, &lt;code&gt;_invokeQueue&lt;/code&gt; will have the following entry:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-javascript&#34;&gt;[&#39;$provide&#39;, &#39;factory&#39;, [&#39;aNiceModule&#39;, function() {...}]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The service gets registered using the built in &lt;code&gt;$provideProvider&lt;/code&gt;. The service is then available to the injector to inject into any other service that needs it.&lt;/p&gt;

&lt;p&gt;That pretty much sums up the injector. The rest of Angular JS is built around this core module and it has proved immensely insightful to learn it inside out.&lt;/p&gt;

&lt;p&gt;If you are interested in using it on the server in your nodeJS app, I have pulled out the injector code into &lt;a href=&#34;https://github.com/FungusHumungus/pongular&#34;&gt;it&amp;rsquo;s own module&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Studying the Angular JS Injector - the twin injectors</title>
      <link>http://taoofcode.net/studying-the-angular-injector-the-twin-injectors/</link>
      <pubDate>Wed, 26 Feb 2014 00:00:00 +0000</pubDate>
      
      <guid>http://taoofcode.net/studying-the-angular-injector-the-twin-injectors/</guid>
      <description>

&lt;p&gt;(This post is part of a series &lt;a href=&#34;http://taoofcode.net/studying-the-angular-injector/&#34;&gt;studying the AngularJS injector&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;When Angular creates the injector, it actually creates two injectors:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-javascript&#34;&gt;providerInjector = (providerCache.$injector =
    createInternalInjector(providerCache, function() {
        throw $injectorMinErr(&#39;unpr&#39;, &amp;quot;Unknown provider: {0}&amp;quot;, path.join(&#39; &amp;lt;- &#39;));
    })),
          
instanceInjector = (instanceCache.$injector =
    createInternalInjector(instanceCache, function(servicename) {
        var provider = providerInjector.get(servicename + providerSuffix);
        return instanceInjector.invoke(provider.$get, provider);
    }));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Two parameters are passed to the createInternalInjector function. The first is the cache to use to look up instances (a simple object). The second is a factory function. The factory function is used to create a service when it doesn&amp;rsquo;t exist in the cache.&lt;/p&gt;

&lt;h3 id=&#34;the-instanceinjector:d2ecef1c64679de946baa5fa649c7596&#34;&gt;the instanceInjector&lt;/h3&gt;

&lt;p&gt;The instanceInjector is the injector that is returned when you call createInjector.&lt;/p&gt;

&lt;p&gt;The instanceInjector stores the list of instantiated services in the system. It is initialised with an empty object. The providerInjector maintains the list of uninstantiated services.&lt;/p&gt;

&lt;p&gt;Looking at the factory function for instance injector, when we are trying to fetch a service that has not yet been instantiated, we will look up the service name in the providerInjector with the name &lt;code&gt;servicename + providerSuffix&lt;/code&gt;. providerSuffix is the string &lt;code&gt;Provider&lt;/code&gt;. When we have this we invoke the &lt;code&gt;$get&lt;/code&gt; function of the provider object.&lt;/p&gt;

&lt;p&gt;There are two assumptions made here.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;All services stored in the &lt;code&gt;providerInjector&lt;/code&gt; are named with a suffix &lt;code&gt;Provider&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;All services stored in the &lt;code&gt;providerInjector&lt;/code&gt; are objects with a &lt;code&gt;$get&lt;/code&gt; function.&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;the-providerinjector:d2ecef1c64679de946baa5fa649c7596&#34;&gt;the providerInjector&lt;/h3&gt;

&lt;p&gt;Lets see how the providerInjector is set up.&lt;/p&gt;

&lt;p&gt;The cache for the providerInjector is initialised with one service - $provide :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-javascript&#34;&gt; providerCache = {
        $provide: {
            provider: supportObject(provider),
            factory: supportObject(factory),
            service: supportObject(service),
            value: supportObject(value),
            constant: supportObject(constant),
            decorator: decorator
          }
      }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The $provide service is always available on the providerInjector by default. It is through this service that all other services are registered.&lt;/p&gt;

&lt;p&gt;supportObject is the following method:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-javascript&#34;&gt;function supportObject(delegate) {
    return function(key, value) {
      if (isObject(key)) {
        forEach(key, reverseParams(delegate));
      } else {
        return delegate(key, value);
      }
    };
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is a very common javascript pattern. A function that captures a variable (in this case &lt;code&gt;delegate&lt;/code&gt;) that then returns another function.&lt;/p&gt;

&lt;p&gt;The returned function from &lt;code&gt;supportObject&lt;/code&gt; will apply the delegate to the parameters, or if an object is passed in apply the delegate to all the fields of that object.&lt;/p&gt;

&lt;p&gt;The delegate passed in is a function that handles the creation of either a provider, factory, service, value or constant. Each of these work slightly differently, but they all end up adding a service to the providerCache named with a &lt;code&gt;Provider&lt;/code&gt; suffix and having a &lt;code&gt;$get&lt;/code&gt; member function.&lt;/p&gt;

&lt;h4 id=&#34;provider:d2ecef1c64679de946baa5fa649c7596&#34;&gt;provider&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-javascript&#34;&gt;  function provider(name, provider_) {
    assertNotHasOwnProperty(name, &#39;service&#39;);
    if (isFunction(provider_) || isArray(provider_)) {
      provider_ = providerInjector.instantiate(provider_);
    }
    if (!provider_.$get) {
      throw $injectorMinErr(&#39;pget&#39;, &amp;quot;Provider &#39;{0}&#39; must define $get factory method.&amp;quot;, name);
    }
    return providerCache[name + providerSuffix] = provider_;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the given provider is a function or an array, that provider is invoked. Then we validate to ensure a $get property is included in the provider and the object is added to the &lt;code&gt;providerCache&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&#34;factory:d2ecef1c64679de946baa5fa649c7596&#34;&gt;factory&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-javascript&#34;&gt;  function factory(name, factoryFn) { return provider(name, { $get: factoryFn }); }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A factory just creates a provider with a $get property that points to the passed in factory function.&lt;/p&gt;

&lt;h4 id=&#34;service:d2ecef1c64679de946baa5fa649c7596&#34;&gt;service&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-javascript&#34;&gt;function service(name, constructor) {
    return factory(name, [&#39;$injector&#39;, function($injector) {
      return $injector.instantiate(constructor);
    }]);
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A service creates a factory. The method is annotated to retrieve the &lt;code&gt;$injector&lt;/code&gt; object. The injector is used to instantiate the an instance of the constructor class that is passed to the service.&lt;/p&gt;

&lt;h4 id=&#34;value:d2ecef1c64679de946baa5fa649c7596&#34;&gt;value&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-javascript&#34;&gt;function value(name, val) { return factory(name, valueFn(val)); }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A value creates a factory with a function that returns the value.&lt;/p&gt;

&lt;h4 id=&#34;constant:d2ecef1c64679de946baa5fa649c7596&#34;&gt;constant&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-javascript&#34;&gt; function constant(name, value) {
    assertNotHasOwnProperty(name, &#39;constant&#39;);
    providerCache[name] = value;
    instanceCache[name] = value;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Constants break the $get and provider suffix rules. The value just gets set directly in both the provider and instance caches as there is no processing that needs doing to instantiate a constant.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;So why would they implement this twin injector solution? Couldn&amp;rsquo;t they mix all the instantiated and uninstantiated services into one injector? Their names are already distinguished by the &lt;code&gt;provider&lt;/code&gt; suffix on the uninstantiated services.&lt;/p&gt;

&lt;p&gt;One reason is hiding functionality. Supposing you wanted to register a service with the injector directly. If you tried you would get the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-javascript&#34;&gt;&amp;gt; var injector = angular.injector()
&amp;gt; injector.get(&#39;$provide&#39;).value(&#39;myValue&#39;, 3.14);
Error: [$injector:unpr] Unknown provider: $providerProvider &amp;lt;- $provider
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You only have access to the instanceInjector. When this does a lookup on the providerInjector, it adds the Provider suffix to the name. It attempts to lookup $providerProvider, which doesn&amp;rsquo;t exist.&lt;/p&gt;

&lt;p&gt;So if we can&amp;rsquo;t access $provider how can we register our services with the Injector?&lt;/p&gt;

&lt;p&gt;This is all done via modules. All services set up in angular must be attached to a particular module and this is the only way to register the service with the injector.&lt;/p&gt;

&lt;p&gt;Next: &lt;a href=&#34;http://taoofcode.net/studying-the-angular-injector-loading-modules&#34;&gt;loadModules&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Studying the Angular JS Injector - getService</title>
      <link>http://taoofcode.net/studying-the-angular-injector-getservice/</link>
      <pubDate>Mon, 24 Feb 2014 00:00:00 +0000</pubDate>
      
      <guid>http://taoofcode.net/studying-the-angular-injector-getservice/</guid>
      <description>&lt;p&gt;(This post is part of a series &lt;a href=&#34;http://taoofcode.net/studying-the-angular-injector/&#34;&gt;studying the AngularJS injector&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;getService&lt;/code&gt; function is the work-horse of &lt;code&gt;invoke&lt;/code&gt;. This is the method that takes a service name and attempts to locate it in the list of registered services.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-javascript&#34;&gt;    function getService(serviceName) {
      if (cache.hasOwnProperty(serviceName)) {
        if (cache[serviceName] === INSTANTIATING) {
          throw $injectorMinErr(&#39;cdep&#39;, &#39;Circular dependency found: {0}&#39;, path.join(&#39; &amp;lt;- &#39;));
        }
        return cache[serviceName];
      } else {
        try {
          path.unshift(serviceName);
          cache[serviceName] = INSTANTIATING;
          return cache[serviceName] = factory(serviceName);
        } catch (err) {
          if (cache[serviceName] === INSTANTIATING) {
            delete cache[serviceName];
          }
          throw err;
        } finally {
          path.shift();
        }
      }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When the injector is created it is passed two parameters, &lt;code&gt;cache&lt;/code&gt; and &lt;code&gt;factory&lt;/code&gt;. These are critical and we will break these down soon. For now the cache is a list of services that have been instantiated and factory is a method that instantiates a service given it&amp;rsquo;s name.&lt;/p&gt;

&lt;p&gt;If the service already exists in the cache, it looks to see if the service is actually the &lt;code&gt;INSTANTIATING&lt;/code&gt; placeholder. If it is, this means that whilst instantiating this service it has invoked another service that is then trying to instantiate this one again - a circular dependency. The injector can&amp;rsquo;t deal with this so it throws an error. Otherwise the service is just returned.&lt;/p&gt;

&lt;p&gt;If the service is not in the cache it needs to be instantiated.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-javascript&#34;&gt;    path.unshift(serviceName);
    cache[serviceName] = INSTANTIATING;
    return cache[serviceName] = factory(serviceName);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The service name is added to the beginning of the &lt;code&gt;path&lt;/code&gt; array. This is just an array used to keep track of the route taken through services as the injector instantiates them. It is used to report useful error messages when something goes wrong.&lt;/p&gt;

&lt;p&gt;The entry in the cache for this service is created and first gets set to this INSTANTIATING placeholder. The &lt;code&gt;factory&lt;/code&gt; function is then called to created our service, its result is stored in the cache and the value is returned.&lt;/p&gt;

&lt;p&gt;Next: &lt;a href=&#34;http://taoofcode.net/studying-the-angular-js-injector-instantiate&#34;&gt;instantiate&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Studying the Angular JS Injector - invoke</title>
      <link>http://taoofcode.net/studying-the-angular-injector-invoke/</link>
      <pubDate>Mon, 24 Feb 2014 00:00:00 +0000</pubDate>
      
      <guid>http://taoofcode.net/studying-the-angular-injector-invoke/</guid>
      <description>&lt;p&gt;(This post is part of a series &lt;a href=&#34;http://taoofcode.net/studying-the-angular-injector/&#34;&gt;studying the AngularJS injector&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;The invoke method invokes the given function with the parameters injected.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-javascript&#34;&gt;function invoke(fn, self, locals){
      var args = [],
          $inject = annotate(fn),
          length, i,
          key;

      for(i = 0, length = $inject.length; i &amp;lt; length; i++) {
        key = $inject[i];
        if (typeof key !== &#39;string&#39;) {
          throw $injectorMinErr(&#39;itkn&#39;,
                  &#39;Incorrect injection token! Expected service name as string, got {0}&#39;, key);
        }
        args.push(
          locals &amp;amp;&amp;amp; locals.hasOwnProperty(key)
          ? locals[key]
          : getService(key)
        );
      }
      if (!fn.$inject) {
        // this means that we must be an array.
        fn = fn[length];
      }

      // http://jsperf.com/angularjs-invoke-apply-vs-switch
      // #5388
      return fn.apply(self, args);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first thing to note is that this method actually takes three parameters, the Angular documentation only mentions the first one.&lt;/p&gt;

&lt;p&gt;Invoke first &lt;a href=&#34;http://taoofcode.net/studying-the-angular-injector-annotate/&#34;&gt;annotates&lt;/a&gt; the method to get a list of its parameters.&lt;/p&gt;

&lt;p&gt;Each of these parameters are then validated to ensure they are a String. Then &lt;code&gt;invoke&lt;/code&gt; locates the value to inject into the method with this code :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-javascript&#34;&gt; args.push(
          locals &amp;amp;&amp;amp; locals.hasOwnProperty(key)
          ? locals[key]
          : getService(key)
        );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First, we look to see if the value is found in the &lt;code&gt;locals&lt;/code&gt; parameter. &lt;a href=&#34;http://docs.angularjs.org/api/ngRoute/provider/$routeProvider&#34;&gt;$routeProvider&lt;/a&gt; uses this in &lt;code&gt;route.resolve&lt;/code&gt; where you can setup additional dependencies to inject into the controller.&lt;/p&gt;

&lt;p&gt;It is also possible to use this to override the registered service. Handy for unit testing.&lt;/p&gt;

&lt;p&gt;If the value is not found in &lt;code&gt;locals&lt;/code&gt;, &lt;code&gt;getService&lt;/code&gt; is called to attempt to locate it.&lt;/p&gt;

&lt;p&gt;Once all parameters are retrieved, the function is called with these parameters using &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply&#34;&gt;apply&lt;/a&gt; and its result is returned.&lt;/p&gt;

&lt;p&gt;Next: &lt;a href=&#34;http://taoofcode.net/studying-the-angular-injector-getservice&#34;&gt;getService&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Studying the Angular JS Injector - instantiate</title>
      <link>http://taoofcode.net/studying-the-angular-js-injector-instantiate/</link>
      <pubDate>Mon, 24 Feb 2014 00:00:00 +0000</pubDate>
      
      <guid>http://taoofcode.net/studying-the-angular-js-injector-instantiate/</guid>
      <description>&lt;p&gt;(This post is part of a series &lt;a href=&#34;http://taoofcode.net/studying-the-angular-injector/&#34;&gt;studying the AngularJS injector&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;Whilst &lt;code&gt;invoke&lt;/code&gt; calls a function with it&amp;rsquo;s parameters injected, &lt;code&gt;instantiate&lt;/code&gt; will contruct a new object with it&amp;rsquo;s constructor parameters injected.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;instantiate&lt;/code&gt; gives us an excellent insight into how javascript objects work. In javascript, a class is just a function and an class instance is just a function that has been invoked with the &lt;code&gt;new&lt;/code&gt; operator.&lt;/p&gt;

&lt;p&gt;Say we have a simple class :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-javascript&#34;&gt;function Person(firstName, lastName) {
    this.firstName = firstName;
    this.lastName = lastName;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can add methods to this class via the functions &lt;code&gt;prototype&lt;/code&gt; property.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-javascript&#34;&gt;Person.prototype.beNiceTo = function() {
    console.log(this.firstName + &#39; &#39; + this.lastName + &#39; is my friend&#39;;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we can create an instance of this class with &lt;code&gt;new&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-javascript&#34;&gt;&amp;gt; var plum = new Person(&#39;Professor&#39;, &#39;Plonk&#39;);
&amp;gt; plum.beNiceTo();
Professor Plonk is my friend
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All is good.&lt;/p&gt;

&lt;p&gt;Now in order to invoke a method and inject parameters into it, the Injector takes advantage of the &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply&#34;&gt;apply&lt;/a&gt; method. This method allows you to invoke a function and pass in an array which will become that functions parameters.&lt;/p&gt;

&lt;p&gt;Very useful, but the problem with &lt;code&gt;apply&lt;/code&gt; is that it only works when you want to call a function. There is no way to mix &lt;code&gt;new&lt;/code&gt; with &lt;code&gt;apply&lt;/code&gt;. The Injector gets around this problem in a pretty clever way.&lt;/p&gt;

&lt;p&gt;Lets look at the code.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-javascript&#34;&gt;function instantiate(Type, locals) {
      var Constructor = function() {},
          instance, returnedValue;

      // Check if Type is annotated and use just the given function at n-1 as parameter
      // e.g. someModule.factory(&#39;greeter&#39;, [&#39;$window&#39;, function(renamed$window) {}]);
      Constructor.prototype = (isArray(Type) ? Type[Type.length - 1] : Type).prototype;
      instance = new Constructor();
      returnedValue = invoke(Type, instance, locals);

      return isObject(returnedValue) || isFunction(returnedValue) ? returnedValue : instance;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First we create a new, completely empty, object called &lt;code&gt;Constructor&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;If we had passed the above Person class into this method (into the Type parameter) we would then have these two classes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+--------------+ +---------------+
|  beNiceTo    | |               |
+--------------+ +---------------+
       ^                 ^
       |                 |
       |    Prototype    |
       |                 |
+------+-------+ +-------+-------+
|  Type        | | Constructor   |
|--------------| |---------------|
|              | |               |
|              | |               |
+--------------+ +---------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, we set our Constructors prototype to this new Constructors prototype. Copying methods between class prototypes is completely legal to do in javascript - it really is a very malleable language. Note, if Type is an array, this means that it is actually an annotated array - &lt;code&gt;[&#39;$scope&#39;, function($scope) { }]&lt;/code&gt; and the classes constructor function is actually the last element of the array.&lt;/p&gt;

&lt;p&gt;We now have these two classes :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+--------------+
|  beNiceTo    | +-------+
+--------------+         |
       ^                 |
       |                 |
       |    Prototype    |
       |                 |
+------+-------+ +-------+-------+
|  Type        | | Constructor   |
|--------------| |---------------|
|              | |               |
|              | |               |
+--------------+ +---------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;An instance of this class is then created. This doesn&amp;rsquo;t do too much yet. It creates an object with our Types instance methods, but it hasn&amp;rsquo;t actually invoked the constructor yet.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+--------------+
|  beNiceTo    | +-------+
+--------------+         |
       ^                 |
       |                 |
       |    Prototype    |
       |                 |
+------+-------+ +-------+-------+
|  Type        | | Constructor   |
|--------------| |---------------|
|              | |               |
|              | |               |
+--------------+ +---------------+
                         ^
                         |
                         |
                 +-------+-------+
                 |   Instance    |
                 |---------------|
                 |               |
                 |               |
                 +---------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We still need to invoke this constructor and inject the parameters into it. To do this we call &lt;code&gt;invoke&lt;/code&gt; with our type as normal.&lt;/p&gt;

&lt;p&gt;There is one significant difference - we pass the new Constructor instance that we have just created. When &lt;code&gt;invoke&lt;/code&gt; calls the method with the injected parameters it does this using &lt;code&gt;fn.apply(self, args)&lt;/code&gt;. Looking back at the &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply&#34;&gt;apply&lt;/a&gt; documentation, the first parameter sent will become the &lt;code&gt;this&lt;/code&gt; variable in the function. So, by invoking with our newly created class, the constructor is called against it.&lt;/p&gt;

&lt;p&gt;So we have managed to create our new class without ever actually calling &lt;code&gt;new&lt;/code&gt; on it.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+--------------+
|  beNiceTo    | +-------+
+--------------+         |
       ^                 |
       |                 |
       |    Prototype    |
       |                 |
+------+-------+ +-------+-------+
|  Type        | | Constructor   |
|--------------| |---------------|
|              | |               |
|              | |               |
+--------------+ +---------------+
                         ^
                         |
                         |
                 +-------+-------+
                 |   Instance    |
                 |---------------|
                 | Professor     |
                 | Plonk         |
                 +---------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This instance with injected parameters is then returned.&lt;/p&gt;

&lt;p&gt;Next, we will tie everything together by looking at how the Injector is set up: &lt;a href=&#34;http://taoofcode.net/studying-the-angular-injector-the-twin-injectors&#34;&gt;the twin injectors&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Studying the Angular JS Injector - annotate</title>
      <link>http://taoofcode.net/studying-the-angular-injector-annotate/</link>
      <pubDate>Wed, 19 Feb 2014 00:00:00 +0000</pubDate>
      
      <guid>http://taoofcode.net/studying-the-angular-injector-annotate/</guid>
      <description>&lt;p&gt;(This post is part of a series &lt;a href=&#34;http://taoofcode.net/studying-the-angular-injector/&#34;&gt;studying the AngularJS injector&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;In order for the Injector to know what to inject into a given functions parameters, it needs a list of these parameters. This is what the &lt;code&gt;annotate&lt;/code&gt; function does.&lt;/p&gt;

&lt;p&gt;There are three different ways in Angular to annotate your methods.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Use an array. The last element of the array is the function, the rest is a list of the parameter names.
&lt;code&gt;language-javascript
[&#39;$scope&#39;, &#39;$q&#39;, function($scope, $q) {}
&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Add a &lt;code&gt;$inject&lt;/code&gt; property to the function containing a list of the parameters.
&lt;code&gt;language-javascript
function myFunction($scope, $q) {}
myFunction.$inject = [&#39;$scope&#39;, &#39;$q&#39;];
&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Nothing at all. Angular can parse the parameters straight out of the function. This does not work when your code is minified since the minification renames your parameters to the smallest length possible.
&lt;code&gt;language-javascript
function myFunction($scope, $q) {}
&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Lets look at the code.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-javascript&#34;&gt;var FN_ARGS = /^function\s*[^\(]*\(\s*([^\)]*)\)/m;
var FN_ARG_SPLIT = /,/;
var FN_ARG = /^\s*(_?)(\S+?)\1\s*$/;
var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
var $injectorMinErr = minErr(&#39;$injector&#39;);
function annotate(fn) {
  var $inject,
      fnText,
      argDecl,
      last;

  if (typeof fn == &#39;function&#39;) {
    if (!($inject = fn.$inject)) {
      $inject = [];
      if (fn.length) {
        fnText = fn.toString().replace(STRIP_COMMENTS, &#39;&#39;);
        argDecl = fnText.match(FN_ARGS);
        forEach(argDecl[1].split(FN_ARG_SPLIT), function(arg){
          arg.replace(FN_ARG, function(all, underscore, name){
            $inject.push(name);
          });
        });
      }
      fn.$inject = $inject;
    }
  } else if (isArray(fn)) {
    last = fn.length - 1;
    assertArgFn(fn[last], &#39;fn&#39;);
    $inject = fn.slice(0, last);
  } else {
    assertArgFn(fn, &#39;fn&#39;, true);
  }
  return $inject;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;annotate&lt;/code&gt; is passed either an array or a function.&lt;/p&gt;

&lt;p&gt;If an array has been passed into &lt;code&gt;annotate&lt;/code&gt;, it is assumed to be in the first form (&lt;code&gt;[&#39;$scope&#39;, function($scope) {..&lt;/code&gt;). In this case, we assert that the last element in the array is a function and then remove that element returning the array.&lt;/p&gt;

&lt;p&gt;If it is just a function passed in, first it checks if the function has already been annotated by setting a &lt;code&gt;$inject&lt;/code&gt; property.
&lt;code&gt;language-javascript
    if (!($inject = fn.$inject)) {
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;If it hasn&amp;rsquo;t been, we need to extract the parameters from the function definition itself. This part of the code gives us an enjoyable journey through the power of regular expressions.
&lt;code&gt;language-javascript
      $inject = [];
      if (fn.length) {
        fnText = fn.toString().replace(STRIP_COMMENTS, &#39;&#39;);
        argDecl = fnText.match(FN_ARGS);
        forEach(argDecl[1].split(FN_ARG_SPLIT), function(arg){
          arg.replace(FN_ARG, function(all, underscore, name){
            $inject.push(name);
          });
        });
      }
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Angular takes advantage of the fact that calling &lt;code&gt;toString()&lt;/code&gt; on a function definition returns the full text of the function. We can see this in the nodejs repl:
&lt;code&gt;language-javascript
&amp;gt; var x = function(a,b,c) { };
undefined
&amp;gt; x.toString();
&#39;function(a,b,c) { }&#39;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;toString()&lt;/code&gt; returns the function exactly as it has been entered in the script, including comments.&lt;/p&gt;

&lt;p&gt;These comments get in the way of parsing the parameters, so first the method strips any comments from the function. Anything that matches the regex &lt;code&gt;/((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg&lt;/code&gt; is removed. The first part of that regex (&lt;code&gt;(\/\/.*$)&lt;/code&gt;) matches anything starting with // up to the end of the line. The second part (&lt;code&gt;(\/\*[\s\S]*?\*\/)&lt;/code&gt;) matches anything between a /* and */.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s see if this works :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-javascript&#34;&gt;&amp;gt;var fn = function(c/*a parameter*/, a, // More parameters
...                 /* Interesting */ r) { };
&amp;gt; fn.toString().replace(/((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg, &#39;&#39;);
&#39;function (c, a,
                  r) { }&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It works, the comments are stripped out.&lt;/p&gt;

&lt;p&gt;Next it pulls out the argument list with the regex match : &lt;code&gt;/^function\s*[^\(]*\(\s*([^\)]*)\)/m&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This regex is bordering on the complex. Let&amp;rsquo;s break it down.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;^&lt;/strong&gt; : From the start of the string&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;function&lt;/strong&gt; : match the text &lt;em&gt;function&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;\s&lt;/strong&gt;* : any amount of whitespace&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;[^\(]&lt;/strong&gt;* : any character that is not a &amp;lsquo;(&amp;rsquo;. This will be whitespace and the function name.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;\(&lt;/strong&gt; : the &amp;lsquo;(&amp;rsquo; character. Note ( is a special char in regular expressions, so the &amp;lsquo;\&amp;rsquo; is needed to escape it and make the regex treat it as a real character.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;\s&lt;/strong&gt;* : more whitespace&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;([^)]*)&lt;/strong&gt; : Any character that is not a &amp;lsquo;)&amp;rsquo;. Also note that this part of the pattern is within &amp;lsquo;(&amp;rsquo; and &amp;lsquo;)&amp;rsquo;. This is a group and means we are especially interested in what is matched here.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;)&lt;/strong&gt; : The closing &amp;lsquo;)&amp;rsquo;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Does it work?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-javascript&#34;&gt;&amp;gt;fnText.match(/^function\s*[^\(]*\(\s*([^\)]*)\)/m)
[ &#39;function (c, a, \r\n                  r)&#39;,
  &#39;c, a, \r\n                  r&#39;,
  index: 0,
  input: &#39;function (c, a, \r\n                  r) { }&#39; ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;match&lt;/code&gt; returns an array of the matches found by the regex. The first element in the array is the whole text matched. Each ensuing element is each group found within the regex. The group matched here is anything between the brackets after the text &amp;lsquo;function&amp;rsquo;. In this case it is the text &lt;code&gt;&#39;c, a, \r\n                  r&#39;,&lt;/code&gt; which is our parameter list (plus the newlines and white space).&lt;/p&gt;

&lt;p&gt;The code then splits this string at the commas. For each of these then does a further call to replace.
&lt;code&gt;language-javascript
arg.replace(FN_ARG, function(all, underscore, name){
            $inject.push(name);
          });
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Now looking at the documentation for &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace&#34;&gt;replace&lt;/a&gt; you are supposed to call this function with the search string and a function which is supposed to return the string that you replace it with. This code doesn&amp;rsquo;t do this. Instead it just takes the matched string and pushes it into the &lt;code&gt;$inject&lt;/code&gt; array, ignoring any return value. An interesting and neat way to find matches within text.&lt;/p&gt;

&lt;p&gt;Lets look at the regex used to match these parameters &lt;code&gt;/^\s*(_?)(\S+?)\1\s*$/&lt;/code&gt; :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;^&lt;/strong&gt; : the beginning of the parameter text&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;\s&lt;/strong&gt;* : any amount of whitespace&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;(__?)&lt;/strong&gt; : 0 or more &amp;lsquo;__&amp;rsquo; characters.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;(\S+?)&lt;/strong&gt; : 1 or more non-whitespace characters. The ? makes it a lazy match, it will match as few characters as possible - so this will stop matching when we get to the underscores defined in the next section.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;\1&lt;/strong&gt; : This matchs the substring that is the same as that in group 1. This is the underscores. The effect of this is to ensure that if our parameter starts with a certain number of _ characters that it will end with the same amount.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;\s&lt;/strong&gt;* : any amount of whitespace&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;An interesting point to take away from this pattern is that in your Angular module you can surround your parameters with any number of underscores and (as long as there is the same amount on either side) these will not be included in the annotation and consequent service location.&lt;/p&gt;

&lt;p&gt;Phew, that&amp;rsquo;s a lot of regex.&lt;/p&gt;

&lt;p&gt;We should now have a list of the parameters which the injector can then use to locate the values to inject into our function.&lt;/p&gt;

&lt;p&gt;Next: &lt;a href=&#34;http://taoofcode.net/studying-the-angular-injector-invoke&#34;&gt;invoke&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Studying the Angular JS Injector - intro</title>
      <link>http://taoofcode.net/studying-the-angular-injector/</link>
      <pubDate>Wed, 19 Feb 2014 00:00:00 +0000</pubDate>
      
      <guid>http://taoofcode.net/studying-the-angular-injector/</guid>
      <description>

&lt;p&gt;I am truly impressed with the elegance of AngularJS and have been studying the source code to fully understand it. In this series I will be studying the Injector module as this is one of the core modules around which the rest of the framework revolves.&lt;/p&gt;

&lt;p&gt;In &lt;a href=&#34;https://github.com/angular/angular.js/blob/481508d0e7ae9e4984ea380b9a43e589551c7a5b/src/auto/injector.js&#34;&gt;src/auto/injector.js&lt;/a&gt; there is a method &lt;code&gt;createInjector&lt;/code&gt;. It is this method that kicks off the whole process.&lt;/p&gt;

&lt;p&gt;After a bit of setup this method returns an &lt;code&gt;instanceInjector&lt;/code&gt; object.&lt;/p&gt;

&lt;h3 id=&#34;instanceinjector:e0121710bcdcbbc64b43438aa68f6551&#34;&gt;instanceInjector&lt;/h3&gt;

&lt;p&gt;The injector is an object with the following functions:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-javascript&#34;&gt;    return {
      invoke: invoke,
      instantiate: instantiate,
      get: getService,
      annotate: annotate,
      has: function(name) {
        return providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name);
      }
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First we go through these methods in turn.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://taoofcode.net/studying-the-angular-injector-annotate&#34;&gt;annotate&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://taoofcode.net/studying-the-angular-injector-invoke&#34;&gt;invoke&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://taoofcode.net/studying-the-angular-injector-getservice&#34;&gt;get&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://taoofcode.net/studying-the-angular-js-injector-instantiate&#34;&gt;instantiate&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Then we tie it all together by looking closer at the createInjector method to see how the injector is setup and used : &lt;a href=&#34;studying-the-angular-injector-the-twin-injectors&#34;&gt;the twin injectors&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Finally we look into how a module is loaded and the services are registered with the injectors: &lt;a href=&#34;http://taoofcode.net/studying-the-angular-injector-loading-modules&#34;&gt;loadModules&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Promise Anti-patterns</title>
      <link>http://taoofcode.net/promise-anti-patterns/</link>
      <pubDate>Wed, 12 Feb 2014 00:00:00 +0000</pubDate>
      
      <guid>http://taoofcode.net/promise-anti-patterns/</guid>
      <description>

&lt;p&gt;Promises are very simple once you get your head around them, but there are a few gotchas that can leave you with your head scratching. Here are a few that got me.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;nested-promises:8f173b15e2d19515fdc8ce931ae539c0&#34;&gt;Nested Promises&lt;/h2&gt;

&lt;p&gt;You get a whole bundle of promises nested in eachother:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-javascript&#34;&gt;loadSomething().then(function(something) {
    loadAnotherthing().then(function(another) {
                    DoSomethingOnThem(something, another);
    });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The reason you&amp;rsquo;ve done this is because you need to do something with the results of both promises, so you can&amp;rsquo;t chain them since the &lt;code&gt;then()&lt;/code&gt; is only passed the result of the previous return.&lt;/p&gt;

&lt;p&gt;The real reason you&amp;rsquo;ve done this is because you don&amp;rsquo;t know about the &lt;code&gt;all()&lt;/code&gt; method.&lt;/p&gt;

&lt;p&gt;To fix :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-javascript&#34;&gt;q.all([loadSomething(), loadAnotherThing()])
    .spread(function(something, another) {
        DoSomethingOnThem(something, another);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Much simpler. The promise returned by &lt;code&gt;q.all&lt;/code&gt; will resolve with an array of the results that is passed to &lt;code&gt;then()&lt;/code&gt;. The &lt;code&gt;spread()&lt;/code&gt; method will split this array up amongst the parameters.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;the-broken-chain:8f173b15e2d19515fdc8ce931ae539c0&#34;&gt;The Broken Chain&lt;/h2&gt;

&lt;p&gt;You have code like :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-javascript&#34;&gt;function anAsyncCall() {
    var promise = doSomethingAsync();
    promise.then(function() {
        somethingComplicated();
    });
    
    return promise;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The problem here is that any error raised in the &lt;code&gt;somethingComplicated()&lt;/code&gt; method will not get caught. Promises are meant to be chained - each call to &lt;code&gt;then()&lt;/code&gt; returns a new promise. It is this promise that the next &lt;code&gt;then()&lt;/code&gt; should be called against. Generally the final call will be a &lt;code&gt;catch()&lt;/code&gt;, any errors that are raised anywhere in the chain will be handled here.&lt;/p&gt;

&lt;p&gt;In the above code the chain gets broken when you return the first promise rather than the result of the final &lt;code&gt;then()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The fix:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-javascript&#34;&gt;function anAsyncCall() {
    var promise = doSomethingAsync();
    return promise.then(function() {
        somethingComplicated()
    });   
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Always return the result of the final &lt;code&gt;then()&lt;/code&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;the-collection-kerfuffle:8f173b15e2d19515fdc8ce931ae539c0&#34;&gt;The Collection Kerfuffle&lt;/h2&gt;

&lt;p&gt;You have an array of items and you want to do something asynchronous on each of them. So you find yourself doing something involving recursion.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-javascript&#34;&gt;function workMyCollection(arr) {
    var resultArr = [];
    function _recursive(idx) {
        if (idx &amp;gt;= resultArr.length) return resultArr;
            
        return doSomethingAsync(arr[idx]).then(function(res) {
            resultArr.push(res);
            return _recursive(idx + 1);
        });
    }

    return _recursive(0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ug, the code is hardly intuitive. The problem is that chaining methods when you don&amp;rsquo;t know how many to chain can be painful. That is until you remember &lt;code&gt;map()&lt;/code&gt; and &lt;code&gt;reduce()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;To fix:&lt;/p&gt;

&lt;p&gt;Remember &lt;code&gt;q.all&lt;/code&gt; takes an array of promises and resolves to an array of the results. We can simply map the async calls to their results as follows :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-javascript&#34;&gt;function workMyCollection(arr) {
    return q.all(arr.map(function(item) {
        return doSomethingAsync(item);
    }));    
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Unlike the recursive non-solution, this will kick off all the async calls in parallel. Obviously much more time efficient.&lt;/p&gt;

&lt;p&gt;If you need to run your promises in series, you can use reduce.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-javascript&#34;&gt;function workMyCollection(arr) {
    return arr.reduce(function(promise, item) {
        return promise.then(function(result) {
            return doSomethingAsyncWithResult(item, result);
        });        
    }, q());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Not quite as tidy, but certainly tidier.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;the-ghost-promise:8f173b15e2d19515fdc8ce931ae539c0&#34;&gt;The Ghost Promise&lt;/h2&gt;

&lt;p&gt;A certain method needs to do something asynchronous and sometimes it doesn&amp;rsquo;t. So you create a promise even when you don&amp;rsquo;t need one just to keep the two code paths consistent.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-javascript&#34;&gt;var promise;
if (asyncCallNeeded) 
    promise = doSomethingAsync();
else
    promise = Q.resolve(42);
        
promise.then(function() {
    doSomethingCool();
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Not the worst anti-pattern here, but there is definitely a cleaner way - wrap the &amp;lsquo;value or promise&amp;rsquo; with &lt;code&gt;Q()&lt;/code&gt;. This method will take either a value or a promise and act accordingly.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-javascript&#34;&gt;Q(asyncCallNeeded ? doSomethingAsync() : 42)
    .then(
        function(value){
            doSomethingGood();
        })
    .catch( 
        function(err) {
            handleTheError();
        });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Note: I was originally advising using Q.when there. Thankfully Kris Kowal has put me straight in the comments below. Don&amp;rsquo;t use Q.when, just use Q() - it is much cleaner.&lt;/em&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;the-overly-keen-error-handler:8f173b15e2d19515fdc8ce931ae539c0&#34;&gt;The Overly Keen Error Handler&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;then()&lt;/code&gt; method takes two parameters, the fulfilled handler and the rejected handler. You might be tempted to do something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-javascript&#34;&gt;somethingAsync.then(
    function() {
        return somethingElseAsync();
    },
    function(err) {
        handleMyError(err);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The problem with this is that any errors occurring in the fulfilled handler does not get passed to the error handler.&lt;/p&gt;

&lt;p&gt;To fix, make sure the error handler is in a separate then :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-javascript&#34;&gt;somethingAsync
    .then(function() {
        return somethingElseAsync();
    })
    .then(null,
        function(err) {
            handleMyError(err);
        });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or use &lt;code&gt;catch()&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-javascript&#34;&gt;somethingAsync
    .then(function() {
        return somethingElseAsync();
    })
    .catch(function(err) {
        handleMyError(err);
    });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This ensures any errors occuring in the chain will get handled.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;the-forgotten-promise:8f173b15e2d19515fdc8ce931ae539c0&#34;&gt;The Forgotten Promise&lt;/h2&gt;

&lt;p&gt;You call a method that returns a promise. However, you forget about this promise and create your own one.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-javascript&#34;&gt;var deferred = Q.defer();
doSomethingAsync().then(function(res) {
    res = manipulateMeInSomeWay(res);
    deferred.resolve(res);
}, function(err) {
    deferred.reject(err);
});
    
return deferred.promise;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This really is defeating the point of promises - simplicity. A lot of pointless code here.&lt;/p&gt;

&lt;p&gt;To fix, just return the promise.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-javascript&#34;&gt;return doSomethingAsync().then(function(res) {
    return manipulateMeInSomeWay(res);
});
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>